# 术语和概念

在这一章中，我们试图建立一套通用的术语，作为akka.net所目标的并行分布式系统讨论的基础。请注意，对于这些术语中的许多术语，没有统一的定义。我们只是给出在akka.net文档使用范围内的工作定义。

## 并发与并行性

并发性和并行性是相关概念，但有细微差别。并发意味着两个或多个任务正在取得进展，尽管它们可能不是同时刻执行的。例如，可以用时间切片来实现任务的部分顺序执行，并与其他任务的部分混合。另一方面，并行性在执行可以是真正同时发生时出现。

#### Concurrency
![Concurrence](../images/concurrency.png)

#### Parallelism
![Parallelism](../images/Parallelism.png)

## 异步与同步

如果调用方无法在方法返回值或抛出异常之前取得进展，则方法调用被认为是同步的。另一方面，异步调用允许调用方在有限数量的步骤之后取得进展，并且该方法的完成可以通过一些附加机制（可能是已注册的回调、任务或消息）来表示。

同步API可以使用阻塞来实现同步，但这不是必需的。CPU密集型任务可能会产生类似阻塞的行为。一般来说，最好使用异步API，因为它们保证系统能够前进。Actors 本质上是异步的：一个Actor可以在消息发送后进行，而不必等待实际的传送发生。

## 非阻塞与阻塞

如果一个线程的延迟可以无限期地延迟其他线程，我们就认为是阻塞。一个很好的例子是，一个资源使用互斥，它唯一地被一个线程使用。如果线程无限期地保存资源（例如意外地运行一个无限循环），那么等待资源的其他线程就不能前进。相反，非阻塞意味着没有线程能够无限期地延迟其他的线程。

非阻塞操相比阻塞具有优势，如果包含阻塞操作，作为一个整体系统，无法保证一定取得进展。

## 死锁vs饥饿vs活锁

当几个参与者互相等待以达到某个特定的状态以便能够前进时，就会出现死锁。他们当中没有一个人能进步没有其他参与者达到一定的状态（“两难”问题）所有受影响的系统档。死锁与阻塞密切相关，因为参与者线程可以无限期地延迟其他线程的进程。

在死锁的情况下，没有参与者可以取得进展，而相反，饥饿发生时，有参与者可以取得进展，但可能有一个或多个不能。典型的场景是一个天真的调度算法的情况下，总是选择高优先级的任务在低优先级的。如果输入的高优先级任务数量足够高，就不会有低优先级的任务完成。

活锁类似僵局的参与者没有进步。不同之处在于，参与者并不是在等待他人进步的状态下被冻结，而是不断地改变自己的状态。当两个参与者有两个相同的资源时，一个示例场景。他们每个人都试图获取资源，但他们也检查对方是否需要资源。如果资源由另一个参与者请求，则它们试图获取资源的其他实例。不幸的是，这两个参与者可能会在两种资源之间“反弹”，永远不会得到它，但总是屈从于另一方。

## 竞争条件

当一组事件的排序可能受到外部非确定性效应的影响时，我们称之为竞争条件。当多个线程具有共享的可变状态时，通常会出现竞争状态，并且线程在状态上的操作可能是交错的，从而导致意外行为。虽然这是一个常见的情况，但共享状态不需要具有竞争条件。一个例子可能是一个无序的数据包（如客户端发送UDP数据报）P1，P2到服务器。由于数据包可能通过不同的网络路由传播，因此服务器可能先接收P2和P1。如果消息不包含关于发送顺序的信息，则不可能由服务器确定它们是以不同的顺序发送的。根据包的含义，这可能导致竞争条件。

[注意]，akka.net提供关于某对Actor之间发送的消息的唯一保证的是，他们的次序都是保存。查看[消息传递可靠性]

## 非阻塞保证（进度条件）

如前几节所讨论的，阻塞是不可取的，有几个原因，包括死锁的危险和系统中吞吐量的降低。在下面的部分中，我们将讨论各种不同强度的非阻塞属性。

## Wait-freedom

如果每个调用都保证以有限的步骤完成，则方法是waite-free的。如果一个方法是有界的，那么空闲的步骤数有一个有限上界。

从这个定义可以看出，wait-free的方法不会阻塞，因此死锁不会发生。此外，由于每个参与者都可以在有限数量的步骤之后完成（当调用完成时），waite-free方法不受饥饿的影响。

## Lock-freedom

Lock-free比wait-free更弱。在lock-free调用的情况下，无限常有的方法在有限数量的步骤中完成。这个定义意味着无锁调用不存在死锁。另一方面，保证某些呼叫在有限数量的步骤中完成并不足以保证所有呼叫最终完成。换句话说，锁定自由并不足以保证缺乏饥饿。

## Obstruction-freedom 阻塞自由

阻塞自由是这里讨论的最薄弱的非阻塞保证。一种方法被称为无阻塞，如果有一个时间点在它独立执行之后（其他线程不做任何步骤，例如：暂停），它以一定数量的步骤完成。所有锁定的对象都是无阻塞的，但相反的情况通常是不正确的。

乐观并发控制（OCC）的方法通常是无障碍。OCC的做法是，每个参与者都试图对共享对象上执行的操作，但如果参与者检测冲突的人，则回滚修改，并再次尝试根据计划。如果有一个时间点，其中一个参与者是唯一一个尝试，操作将成功。
