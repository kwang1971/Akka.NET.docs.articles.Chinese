---
uid: message-delivery-reliability
title: Message Delivery Reliability
---

 ＃消息传递可靠性

Akka.NET可帮助您在一台机器上构建使用多处理器核心的可靠应用程序（“scaling up扩展”）或分布在计算机网络上（“scaling out扩大”）。
使这项工作的关键抽象是所有交互在你的代码单元之间 - actor- 通过消息传递发生，这就是为什么精确的语义如何在actor之间传递消息应该是他们自己的章节。
为了给下面的讨论提供一些背景，请考虑一个应用程序跨越多个网络主机。沟通的基本机制是无论是发送给本地应用程序的actor还是发送给远程actor都是一样的，但是当然在交付延迟方面会有明显的差异（可能还取决于网络链路的带宽和消息大小）和可靠性。

显然，在发送远程消息的情况下涉及更多的步骤意味着更多可能出错。

另一方面是这样的本地发送只会在同一应用程序中传递对消息的引用，
对发送的基础对象没有任何限制，另一个方面是本地发送只会在同一个应用程序中传递对消息的引用，编写你的actor，以便每个交互可能是远程的是安全的，悲观的赌注。它意味着只依赖那些始终保证的属性，并在下面详细讨论。这在actor的实施中当然有一些开销。如果您愿意牺牲完整的位置透明度（例如在一组密切合作的actor的情况下），您可以将它们始终放在同一本地应用程序中，并享受更严格的消息传递保证。这种折衷的细节将在下面进一步讨论。 作为补充部分，我们将就如何在内置建立更强的可靠性方面提供一些指导。本章最后讨论了“死信办公室”的作用。







##一般规则这些是消息发送的规则（即`Tell`方法，它也是`Ask`模式的基础）：* **最多一次发送**，即无保证发送* **每个发送者 - 接收者对的消息排序**第一条规则通常也可以在其他Actor实现中找到，而其次是针对Akka.NET。

 ###讨论：“最多一次”意味着什么？

在描述交付机制的语义时，有三个基本类别：

* **最多一次**递送意味着对于递交给该机制的每个消息，该消息被递送零次或一次;更偶然地说，这意味着信息可能会丢失。

* **至少一次**递送意味着对于交给该机制的每个消息，潜在地多次尝试递送它，使得至少一个成功;再次，更加随便地说，这意味着消息可能被复制但不会丢失。

* **只有一次**递送意味着对于递交给该机制的每个消息，只有一次递送给收件人;该消息既不能丢失也不能重复。

第一个是最便宜的性能，最少的实现开销 - 因为它可以在发送端或传输机制中保持状态的情况下以难以忘怀的方式完成。

第二个要求重试来抵消运输损失，这意味着在发送端保持状态并在接收端具有确认机制。

第三个是最昂贵的，因此性能最差 - 因为除了第二个之外，它需要状态保持在接收端以便过滤掉重复的传送。


###讨论：为什么没有保证投递？

问题的核心在于这个保证究竟是什么
意思：
1.该消息在网络上发出？
2.该消息是由另一主机接收的？
3.该消息是否放入目标actor的邮箱？
4.消息开始由目标actor处理？
5.消息由目标actor成功处理？

它们中的每一个都有不同的挑战和成本，显而易见的是，在任何消息传递库都不能遵守的情况下，想想可配置的邮箱类型，以及有界的邮箱如何与第三点交互，或者甚至意味着决定第五点的“成功”部分。

沿着这些相同的路线推理[没人需要可靠的消息]（http://www.infoq.com/articles/no-reliable-messaging）。

发件人知道交互是否成功的唯一有意义的方式是通过接收一个业务级别的确认消息，这不是Akka.NET可以自己编写的东西（我们也不是在写“做我的意思”框架你也不希望我们）。

Akka.NET支持分布式计算并使通信易于失败
通过消息传递显式的，因此它不会试图说谎和模仿
一个有漏洞的抽象。

这是一个在Erlang中取得巨大成功的模型，并要求用户围绕它设计应用程序。

您可以在[Erlang文档]（http://erlang.org/faq/academic.html）（第10.9节和第10.10节）中详细了解这种方法，Akka.NET紧随其后。

在这个问题上的另一个角度是，只提供基本的保证，那些不需要更高可靠性的用例不会支付其实施的成本;总是可以在基本的可靠性基础上增加更高的可靠性，但是为了获得更高的性能，不可能反弹性地去除可靠性。


>  ###讨论：消息次序

更具体的规则是*对于给定的一对演员，从第一个到第二个发送的消息将不会被乱序接收。

这个词直接强调，这个保证只适用于告诉运营商发送到最终目的地时，而不是在采用中介或其他消息传播功能（除非另有说明）时。

保证如下所示：

> Actor``A1``发送消息“M1”，“M2”，“M3”到“A2”。

>Actor``A3``发送消息“M4”，“M5”，“M6”到“A2”。

>这意味着：
> - 如果交付“M1”，则必须在“M2”和“M3”之前交付
> - 如果交付“M2”，则必须在“M3”之前交付
> - 如果交付“M4”，则必须在“M5”和“M6”之前交付
> - 如果交付“M5”，则必须在“M6”之前交付
>``A2``可以看到来自``A1`的消息与来自``A3``的消息交错
> - 由于没有保证传送，任何消息都可能被丢弃，即没有到达“A2”

> [！NOTE]
>值得注意的是，Akka'的保证适用于其中的顺序
邮件排入收件人的邮箱。

如果邮箱
实现不尊重FIFO顺序（例如`PriorityMailbox`），
那么Actor的处理顺序可能会偏离排队
订购。

请注意，此规则是**不可传递**：

>Actor``A``向Actor``C``发送消息“M1”

> Actor``A``然后发送消息``M2``给演员``B``

>Actor``B``将消息``M2``转发给Actor``C``

>Actor``C``可以以任何顺序接收“M1”和“M2”

因果传递排序意味着``M2``从来没有被接收过
Actor ``C``上的``M1`（尽管他们中的任何一个都可能会丢失）。

这个顺序可以
“A”，“B”和“B”时由于不同的信息传递延迟而受到侵犯
“C”位于不同的网络主机上，请参阅下面的更多内容。

> [！NOTE]
>Actor创作被视为从父母发送给孩子的消息，
具有与上面讨论的相同的语义。

向中的Actor发送消息
一种可以用这个初始创建信息重新排序的方式意味着
该消息可能不会到达，因为该Actor还不存在。

一个例子
消息可能到达太早的地方是创建一个远程部署
actor R1，将其引用发送给另一个远程actor R2并让R2发送一个
消息给R1。

定义明确的排序的一个例子是创建的父代
Actor并立即向其发送消息。

###失败的沟通
请注意，上面讨论的排序保证只适用于Actor之间的用户消息。Actor的孩子的失败是通过特殊的系统消息来传递的，这些消息不是相对于普通用户消息而被排序的。尤其是：>子Actor``C``发送消息``M``给它的父节点``P``>子Actor失败，失败``F``>父Actor``P``可能会按照“M”，“F”或“F”，“M”这是因为内部系统消息具有自己的邮箱，因此用户和系统消息的排队调用的排序不能保证排队时间的排序。

##发送应用内（本地）消息的规则

###请小心你对本节的操作！

不建议依靠本节中更强的可靠性，因为它会将您的应用程序绑定到仅限本地的部署：应用程序可能必须以不同的方式进行设计（与仅对某些参与者使用某些本地消息交换模式相反），以便适合在群集上运行我们的信条是“设计一次，以任何你想要的方式部署”，并且为了实现这个目标，你应该只依靠 [General Rules](xref:message-delivery-reliability#the-general-rules) 。

###本地消息发送的可靠性

 非错误条件测试也适用于远程部署），这意味着我们实际上尽最大努力来保持我们的测试稳定。

但是，本地`Tell`操作可能会因为与CLR上的常规方法调用相同的原因而失败：

- `StackOverflowException`
- “OutOfMemoryException”
- 其他：`SystemException`

另外，本地发送可能会以Akka特定的方式失败：

- 如果邮箱不接受邮件（例如完整的`BoundedMailbox`）
- 如果接收者在处理消息时失败或者已经失败

终止

虽然第一个显然是配置问题，但第二个问题值得考虑一下：如果处理过程中出现异常，则消息的发送者不会得到反馈，而是通知管理员。

对于外部观察者来说，这通常不会与丢失的信息区分开来。###本地消息发送次序

假设严格的先进先出信箱上述的非传递性的警告
消息次序保证在一定条件下被消除。

正如你会注意到的那样，这些都很微妙，甚至可能
未来的性能优化将使整个段落无效。

可能非详尽的反指示清单是：

- 在收到顶级演员的第一个回复之前，会有一个锁

保护一个内部临时队列，这个锁定不公平;该

意味着来自不同发件人的入队请求

在Actor的建设过程中（比喻而言，细节更多地涉及）

可能会根据低级线程调度进行重新排序。

因为完全

CLR上不存在公平的锁，这是不可修复的。

- 在构建路由器时使用相同的机制，更多

恰恰是路由ActorRef，因此Actor存在同样的问题

部署路由器。

- 如上所述，问题发生在涉及锁期间的任何地方

排队，这也可能适用于自定义邮箱。

这份清单已经经过仔细汇编，但其他有问题的情况可能会有
逃脱了我们的分析。


###本地消息发送次序

假设严格的先进先出信箱上述的非传递性的警告
消息订购保证在一定条件下被消除。

就像你
将会注意到，这些都非常微妙，甚至有可能
未来的性能优化将使整个段落无效。

该
可能非详尽的反指示清单是：

- 在收到顶级Actor员的第一个回复之前，会有一个锁

保护一个内部临时队列，这个锁定不公平;该

意味着来自不同发件人的入队请求

在Actor的建设过程中（比喻而言，细节更多地涉及）

可能会根据低级线程调度进行重新排序。

因为完全

CLR上不存在公平的锁，这是不可修复的。

- 在构建路由器时使用相同的机制，更多

恰恰是路由ActorRef，因此演员存在同样的问题

部署路由器。

- 如上所述，问题发生在涉及锁期间的任何地方

排队，这也可能适用于自定义邮箱。

这份清单已经经过仔细汇编，但其他有问题的情况可能会有
逃脱了我们的分析。


###本地次序如何与网络次序订购相关联
对于给定的Actor，通过基于TCP的Akka.NET远程传输协议通过网络发送的消息从第一个到第二个直接发送的消息不会被无序接收到。正如前面部分所解释的，在特定条件下，本地消息发送服从传递因果顺序。由于消息传递延迟不同，此顺序可能会受到侵犯。例如：
>节点1上的Actor A向节点3上的actor C发送消息M1
>节点1上的Actor A然后将消息M2发送给节点2上的actor B.
>节点2上的Actor B将消息M2转发给节点3上的actor C.
>Actor C可以以任何顺序接收M1和M2,M1可能需要更长的时间才能“行进”到节点3，而不是M2需要通过节点2“传播”到节点3。


###消息模式

如上所述，对可靠性要求的直接回答
传送是一个明确的ACK-RETRY协议。

这是最简单的形式

- 识别单个消息与消息相关的方法

承认
- 一个重试机制，如果没有及时得到确认，它将重新发送消息
- 接收器检测并丢弃重复的一种方法

由于承诺没有得到保证，第三个变得必要
也要到达。

具有业务级别确认的ACK-RETRY协议是
由Akka.NET持久性模块的[至少一次交付]（xref：至少一次交付）支持。

重复可以
通过跟踪通过[At least once delivery](xref:at-least-once-delivery).发送的消息的标识符来检测。

实现第三部分的另一种方式是处理消息
在业务逻辑的层面上是幂等的。
鼠尾草递送延迟。

例如：

>节点1上的Actor A向节点3上的actor C发送消息M1

>节点1上的Actor A然后将消息M2发送给节点2上的actor B.

>节点2上的Actor B将消息M2转发给节点3上的actor C.

>actorC可以以任何顺序接收M1和M2

M1可能需要更长的时间才能“行进”到节点3，而不是M2需要通过节点2“行进”到节点3。
 ###事件采购事件采购（和分片）是大型网站扩展的原因数十亿用户，这个想法很简单：当一个组件（认为actor）处理一个命令，它将生成一个表示效果的事件列表的命令。这些事件除了被应用于存储之外，还被存储组件的状态。这个计划的好处是只有事件发生被追加到存储中，没有任何变化; 这使完美这个事件流的消费者的复制和缩放（即，组件可能会使用事件流作为复制组件的手段在不同的大陆上表态或对变化作出反应）。如果组件的状态丢失 - 由于机器故障或被推出缓存 - 它可以通过重放事件流（通常使用）很容易重建快照以加速该过程）。[Event-sourcing](xref:persistent-actors)受支持Akka.NET持久性。

 ###带明确确认的邮箱通过实现自定义邮箱类型，可以在接收Actor的端点重试消息处理，以处理临时故障。这种模式在当地的交流环境中非常有用，其中交付保证足以满足应用程序的要求。

during actor termination). ##死信无法发送的消息（并且可以确定这些消息）被传送给一个叫做``/ deadLetters``的合成Actor。这种交付发生在尽力而为的基础上; 它甚至可能在本地机器的单个应用程序内失败（例如在Actor终止时）。通过不可靠的网络传输发送的消息将丢失，而不会成为死信。



###我应该如何使用死信？这个工具主要用于调试，特别是如果一个actor发送的话并不一致地到达（通常在检查死信的地方告诉你，发件人或收件人被设置错了某处）。为了有助于达到此目的，最好避免发送到尽可能使用`DeadLetters`，即用合适的死亡来运行你的应用程序字母记录器（请参阅下面的更多内容）并清理日志输出。这个练习 - 像所有其他 - 需要明智地运用常识：它很可能是避免发送给被终止的Actor使复杂化发送者的代码超过了调试输出清晰度。死信服务遵循与交付相同的规则保证与所有其他消息一样发送，因此不能用于实现保证交付。
 ###我如何收到死信？Actor可以在活动中订阅“Akka.Actor.DeadLetter”类流，请参阅[Event stream](xref:event-bus) 如何做到这一点。订阅的Actor将收到所有的死亡从那时起在（当地）系统中发布的信件。死信不会通过网络传播，如果你想在一个地方收集它们您必须为每个网络节点订阅一位Actor并转发他们手动。还要考虑在该节点可以生成死信确定发送操作失败，对于远程发送可以是本地系统（如果不能建立网络连接）或远程系统（如果您发送的Actor在该时间点不存在）。
###死信是（通常）不令人担忧每一次actor都不会以自己的决定终止，这是一个机会它发送给自己的一些消息丢失了。有一个在通常是良性的复杂关机情况下很容易发生：看到“Akka.Dispatch.Terminate”消息丢失意味着两个提出终止请求，但当然只有一个可以成功。同样，您可能会看到来自儿童的“Akka.Actor.Terminated”消息同时阻止如果父母出现在死信中的actor等级当父母终止时仍然在看孩子。

