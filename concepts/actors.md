---
uid: actors
title: Actors
---
# Actors

前一节关于演员系统解释了演员是如何形成层次结构的，并且是构建应用程序时最小的单位。本节将孤立地看待一个这样的参与者，解释在实现它时遇到的概念。在深度参考了所有的细节，更请参阅F # API或C # API。

演员是状态、行为、邮箱、孩子和监督者策略的容器。所有这些都封装在演员引用后面。一个值得注意的方面是，参与者有一个明确的生命周期，它们不会在不再引用时自动销毁；在创建了一个之后，您有责任确保它最终将被终止，这也使您能够控制当参与者终止时资源是如何释放的。

# Actor

## Actor Reference

如下文详细说明，为了从Actor模型中获益，Actor对象需要从外部屏蔽。因此，Actor在外部使用Actor引用来代表，这些对象可以自由地、无限制地传递。这种分裂成内部和外部对象，使所有所需操作的透明度：重新启动一个Actor，而不需要更新其他地方的引用，将实际的Actor对象放置在远程主机上，向完全不同的应用程序发送消息给Actor。但最重要的方面是，它是不可能从外部看里面的Acrot和获得的保持状态，除非Actor本身不明智地发布此信息。

## State状态

Actor对象通常包含一些变量，这些变量反映了Actor可能处于的可能状态。这可以是显式状态机（例如使用FSM模块），也可以是计数器、监听器集、挂起的请求等。这些数据是使Actor有价值的，而且必须防止其他行为者破坏。好消息是，akka.net Actor概念各有自己的轻量级线程，这对系统的其余部分完全屏蔽。这意味着，不必使用锁来同步访问，只需编写您的Actor代码，而不必担心并发性。

在akka.net幕后，Actor集合跑在线程集上，通常是许多Actor共用一个线程，并随后调用一个Actor可能是在不同的线程处理。akka.net确保执行细节不影响Actor的状态处理单线程性。

因为内部状态对Actor的操作至关重要，所以不一致的状态是致命的。因此，当Actor失败并由其监督者重新启动时，状态将从零开始创建，就像第一次创建Actor一样。这是为了使系统的自愈能力。

可选地，Actor状态可以在重新启动之前自动恢复到状态，通过持久化接收消息并在重新启动后重播它们（请参阅持久性）。

## Behavior

每次处理消息时，它都与当前Actor行为相匹配。行为意味着一个函数，它定义了在那个时间点对消息所采取的动作，如果客户端被授权，则请求转发，否则拒绝。这种行为可能会随着时间的推移而改变，例如，由于不同的客户端随着时间的推移获得授权，或者因为Actor可能进入“退出服务”模式，稍后返回。这些变化是由编码在状态变量是从行为逻辑读达到，或函数本身可以被交换出去时，看到成为unbecome操作。但是，在参与者对象的构建过程中定义的初始行为是特殊的，即演员的重启会将其行为重置为初始的行为。

## Mailbox 邮箱

Actor 的目的是处理消息，而这些信息是从其他Actor（或Actor系统外部）发送给演员的。连接发送者和接收者的片Actor的邮箱：每个Actor都有一个邮箱，所有发件人的消息队列。入队发生的时间顺序发送操作，这意味着从不同的Actor发短信可能没有定义的顺序由于分配Actor跨线程运行时明显的随机性。发送多个消息相同的目标相同的Actor，另一方面，将它们放在同一顺序。

有不同的邮箱实现选择，默认是一种FIFO:处理消息的次序的顺序与它们加入队列顺序相同。这通常是一个很好的默认值，但是应用程序可能需要优先考虑某些消息而不是其他消息。在这种情况下，优先邮箱将入队不总是最后，位置由的消息的优先级，甚至可能在前面。在使用这样的队列时，处理的消息顺序自然会由队列的算法定义，一般来说不是FIFO。

一个重要的特征，akka.net不同于其他Actor模型的实现是当前的行为必须处理下一个出队列的消息，没有扫描邮箱下一个匹配的消息。除非将此行为重写，否则处理消息的失败通常会被视为失败。

## 子Actors

每个Actor都可能是一个主管：如果它为委派子任务创建子Actor，它会自动监督他们。子Actor名单保持在Actor的范围内，Actor可以使用。到列表的修改完成创建（Context.actorof（…））或停止（Context.Stop(Child))，这些行动是立即反映。实际的创建和终止操作以异步的方式在幕后发生，因此他们不会“阻塞”他们的监管者。

## 监管者战略

Actor的最后一部分是处理子Actor故障的策略。故障处理是通过Akka透明地处理，应用一个Supervision and Monitoring的策略，对每个输入故障监控策略。由于这种策略对Actor系统的结构是至关重要的，因此一旦Actor被创建，它就不能改变。

考虑到每个Actor员只有一个这样的策略，这意味着，如果不同的策略适用于不同的子Actor，子Actor应分组在中间监督并与匹配策略，更倾向于Actor系统结构，根据任务分裂成子Actor.

## 当Actor终止时

一旦一个Actor终止，即失败的方式不是通过重新启动处理，停止本身或由其监督者停了下来，它将释放其资源，消耗所有剩余的邮件从邮箱进入系统的“死信信箱”，并将它们转发到事件流EventStream作为deadletters。mailbox 被系统邮箱所取代，把所有的新消息的事件流作为deadletters。不过，这是在尽力而为的基础上进行的，所以不要依赖它来构建“保证交付”。

不只是默默的倾销的消息是我们的灵感来自于试验的原因：我们在事件总线上登记TestEventListner，死者信件转发testeventlistener，并且会记录一个警告每一个死去的信收到这已经非常有助于越快解读测试失败。可以想象，此特性也可用于其他用途。
